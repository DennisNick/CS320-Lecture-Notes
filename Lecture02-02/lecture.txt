Lecture 02/02/2017:

Quick Review:
-------------
-> At first, become the "Philosopher":=> Generic (Specification-lite Implementation), 
  -> overseeing the grand product of the code problem rather than being so rigidly 
  -> specific in your aglorithmic solution.
-> Then become the "Plumber":=> Strategic Implementer (Detail Specific Implementation), 
  -> drafting up the smaller combinational files that will make up the algorithmic 
  -> solution when compiled together

-> Verbal communication of your code is a must, as expected. Good ol presentations. 

Abstract Types:
---------------
-> Refers to a constant/concept of some sort, an unknown noun that is more or less a 
  -> figmentation of your imagination generated by your logical need to solve a problem.
-> Then you have to adapt the concepts to "link" them together, generating the process 
  -> for solving the problem. (syntactically: abstype point)

Psuedocode Emulation of this:
[
[  abstype point  
[  fun draw_line(point1, point2) -> void = point1 *connects to* point2
[
Conceptionally, the function, points, and return value all represent the ideas you wish 
  to implement in relation to this problem. 

-> An issue arises in that the expansion of these concepts, the addition of the them and 
  -> the compounding of them as the problem progressively becomes more complex and consequently 
  -> does the solution, can become more than extreme to manage. 

Sierpinski Triangle:
-Three points of each side -> connect them -> color inner triangle generated. Repeat the 
  -> process indefinitely. It becomes a Sierpinski Triangle. https://en.wikipedia.org/wiki/Sierpinski_triangle

-I wonder if this could possibly generate the fixed area, or if the constraint of triangle 
  -> edges prevents this once you reach an infinite amount.

Draw Sierpinski Code: (Presentation tier)
--------------------------------------------------------------------------------------
abstype point //concept of a point
abstype color //concept of color to fill the triangle

extern
fun drawTriangle(p1: point, p2: point, p3: point): void 
and fun drawSierpinski(p1: point, p2: point, p3: point, clr: color, n0: int): void
and fun midpoint(p1: point, p2: point): point 

/* n0 represents the depth by which you are going to continually create triangles,stopping
 * once the margin/threshold has been reach 
 */
 
implement
drawSierpinski(p1,p2,p3,clr,n0) = 
  if(n0 > 0) then
    let
      val p12 = midpoint(p1,p2)
      val p23 = midpoint(p2,p3)
      val p31 = midpoint(p3,p1)
      val () = drawTriangle(p12, p23, p31, clr)
      val () = drawSierpinski(p1, p12, p31, clr, n0-1)
      val () = drawSierpinski(p12, p2, p23, clr, n0-1)
      val () = drawSierpinski(p31, p23, p3, clr, n0-1)
    in
      // Do nothing lmao
    end // End of the "if-then" clause, simply a convention for this comment
  else // End etc

// val () = do_something(...) /* Simply a call to a pattern matching (c. below) */

--------------------------------------------------------------------------------------

Referral to Re-Use.txt in Lecture01-31:
---------------------------------------
-> There are specific limitations we wish to reconstruct, such as typecasting for some of the function parameters. 
-> Also the need to generalize recursive calls from functions. 

Recurring Relation:
---------------------
-> Used for last problem in Assign02
-> T(n) = T(n/2) + T(n/2) + O(n) == 2*T(n/2)+O(n)
-> Implementation in totality should be O(n*log(n))

-> Relative to the previous Homework implementation:
-> T(n) = T(n/4) + O(1) == O(log4(n))
-> Versus the Stackoverflow: T(n) = 2*T(n/4) + O(1) == O(Sqrt(n))

Pattern Matching:
-----------------
-> A Divide-And-Conquer construct would be highly useful in function arguments
-> This matching is a way of thinking in terms of the Philosopher and Plumber: 
  -> Each implementation of this code, down to the detail specific emblems could share this
  -> same implementation across the board, in both generic and highly specific contexts
  -> Basically, creating code that can be both specific and generic depending on the need.

  Defining a List to Represent a Compound Data Type:
  -> (* datatype mylist = 
      * | mylist_nil of () // mylist_nil : () -> mylist
      * | mylist_cons of (int, mylist) // mylist_cons : (int, mylist) -> mylist
      *
      * val xs0 = mylist_nil() // []
      * val xs1 = mylist_cons(1, xs0) // [1]
      * val xs2 = mylist_cons(2, xs1) // [2, 1]
      * val xs3 = mylist_cons(3, xs2) // [3, 2, 1]
      *
      * fun mylist_length(xs: mylist): int = 
      *     if(is_empty(xs) then 0 else (1 + mylist_length(tail_of(xs)))
      *
      * fun mylist_length(xs: mylist): int = 
      *     case (xs) of 
      *       | mylist_nil() => 0
      *       | mylist_cons(x, xs_tail) => 1 + mylist_length(xs_tail)
      *)
  -> Functional lists are immutable, but you can do this list reconstructing to generate the proper correct list
  -> These datatypes have only constructors




-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*Aside: Shilling of Functional programming in process. Stay tuned for updates. 
*Psychological tip: People are weirdly obsequious on the details of things, the minutia that is relatively useless I guess idk wtf he's talking about tbqh. But I guess the relation appears in CS too. 
*Syntax aside: () represents void return from a process, _ represents a null process that ran, and any variable naming would represent it as a thing I guess.
*Typecheck Aside: Something about this covers both execution and execution path at runtime I guess. Essentially what he's getting at is that a simple misplacing of a parameter in an arument for a function can be detected at runtime as an error and repaired by the coder before they recompile to execute, rather than running incorrect execution of the parameter. 
*Emacs Aside: i dont even use emacs wtf this is racist towards vim users
