Lecture notes 01-31-2017:

Grading breakdown of Homeworks:
-> Doesn't compile = O(25%)
-> Compiles but doesn't pass tests = O(50%)
-> Homework grade is  now only 25% (down from 30%), Quizzes will be 5% makeup of that

Higher-Order functions:
-> Takes other functions, lesser ones, as their arguments. 
-> If function only takes primitive data, it's considered First-Order
-> Compounds as Second-order and so forth

Docker image is an image of a virtual machine. 
Make sure to sync your repository with the original branch, so as to keep your files up to date with Professor Xi's. 

Makefile Layout:
-> First declaration of a compiler to be used

-> Then institute the targets, using the keys like "all:" or "regress:" with the sources to be used. Example:
 regress:: fact; ./$< 
Where fact is the function to be tested, and the ./$< refers to gain the source

-> Be sure that the declaration of your source is up to date. Example:
 fact: fact.dats; $(PATSCC) -o $0 $<
Where this updates the "fact" source with the code inside the fact.dats file

-> Include a clean to help remove all files from the final layout of files and to clean all created executables

The target is generated by all possible dependencies, then if a dependency is updated, so to should the target executable via make.

Back to Program Techniques:
-> And outer function can be represented as a pointer pointing to a sequence of functions
-> Inner functions, however, is a pointer pointing to an environment that can be understood as a closure function
-> Toplevel = Environment-less functions, Lowerlevel = Closure function
-> Closure functions are a compound of outside components. 
-> Top to Closure is easy, the opposite is not. 

Syntax tip: fix can prefix a function toimplement it as an anonymous functions

-> If you see ATSERRORnotenvless compile error, means there is a function provided outside of a top-level function. A closure function cannot stand on its own. Must be encompassed in a top-level environment. 
-> A closure function has to be dynamically allocated on the heap when run, which is an expensive endeavor. This can be problematic on weaker devices like an Arduino or Raspberry Pi.
-> <cloref> means a function is a closure function, imparative that arguments of a higher-level argument should be a closure.
->If you see a malloc_undef error, that means you need to malloc memory but there is no explicit malloc function used. In order to remedy this, you must inform the compiler with a libc malloc function (MEMALLOC_LIBC) or some library malloc function.
-> Expanded Context on TopLevel versus LowerLevel/Closure: The body of an inner function will represent items/objects that are entering from a foreign domain (outside the closure), and we need an environment to surround the closure function and inform the computer what these foreign entities represent on the stack and through pointers in the environment. 

-> General approach to solving a problem computationally:
  - Finding a strategy that solves the problem (presumably at an algorithmic level)
  - Combine details and technical knowledge to help implement the strategy
  - Test the strategies capability over a source of likewise representative problems

-> However, this approach can lead to messy instances of combining the two when the strategies gain concentrated complexity. 
-> So a mended approach would be to consider a general, "philosophic" approach that encompasses the greater component of the problem by also considering other problems like it. 
-> The "plumbing" that follows are through a special implementation of very particular functions that can be applicable to multiple modes of the problem. 
-> Essentially, think of creating an "area" function in your program about Circles, where this area function can be expanded to work for all forms of circles, and possibly even branch to other geometrical shapes. The expanse of this function's specialty onto other problems helps ease the burden of the central algorithm being implemented to solve the problem of Circles.
-> I call it the "Re-use strategy"
c. re-use.txt for a more visually comprehensive example
 
-> Be careful of function call redundancy, which can obfuscate the time complexity of an algorithm.
-> Also be careful of generality, being to general walks yourself off the cliff of thinking about a problem and you fall into the abyss of "what if???????" 

